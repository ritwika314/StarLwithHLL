Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    QUEUE
    LANGLE
    STACK
    RANGLE
    LIST
    PRINTLOG

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> agentDecl mwblock decls initblock
Rule 2     agentDecl -> AGENT BR CID
Rule 3     initblock -> INIT LPAREN RPAREN LCURLY events RCURLY
Rule 4     events -> event events
Rule 5     events -> empty
Rule 6     event -> robotinit
Rule 7     event -> getpos SEMI
Rule 8     event -> varname LPAREN RPAREN LCURLY pre eff RCURLY
Rule 9     event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY
Rule 10    getpos -> varname EQLS GETMYPOS LPAREN RPAREN
Rule 11    robotinit -> ROBOT LPAREN RPAREN SEMI
Rule 12    pre -> PRE LPAREN cond RPAREN SEMI
Rule 13    pre -> PRE LPAREN TRUE RPAREN SEMI
Rule 14    cond -> rel
Rule 15    cond -> expr
Rule 16    cond -> flag
Rule 17    cond -> ISEMPTY LPAREN varname RPAREN
Rule 18    cond -> cond AND cond
Rule 19    cond -> cond OR cond
Rule 20    cond -> NOT expr
Rule 21    cond -> LPAREN cond RPAREN
Rule 22    flag -> DONEFLAG
Rule 23    flag -> FAILFLAG
Rule 24    rel -> expr EQ expr
Rule 25    rel -> expr NEQ expr
Rule 26    rel -> expr GEQ expr
Rule 27    rel -> expr LEQ expr
Rule 28    rel -> expr GE expr
Rule 29    rel -> expr LE expr
Rule 30    eff -> EFF LCURLY stmts RCURLY
Rule 31    stmts -> stmt stmts
Rule 32    stmts -> empty
Rule 33    stmt -> asgn
Rule 34    stmt -> exit
Rule 35    stmt -> ite
Rule 36    stmt -> atomic
Rule 37    stmt -> remove
Rule 38    stmt -> update
Rule 39    stmt -> msg
Rule 40    stmt -> funcCall
Rule 41    stmt -> getInput
Rule 42    stmt -> varname EQLS funcCall
Rule 43    stmt -> doreachavoid
Rule 44    stmt -> return
Rule 45    stmt -> log
Rule 46    update -> UPDATE LPAREN varname RPAREN SEMI
Rule 47    getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI
Rule 48    msg -> MSG LPAREN varname RPAREN SEMI
Rule 49    log -> LOG LPAREN RPAREN SEMI
Rule 50    log -> LOG LPAREN DONEFLAG RPAREN SEMI
Rule 51    log -> LOG LPAREN FAILFLAG RPAREN SEMI
Rule 52    remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI
Rule 53    exit -> EXIT SEMI
Rule 54    return -> RETURN expr SEMI
Rule 55    doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
Rule 56    ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
Rule 57    funcCall -> varname LPAREN args RPAREN SEMI
Rule 58    args -> empty
Rule 59    args -> neargs
Rule 60    neargs -> expr
Rule 61    neargs -> expr COMMA neargs
Rule 62    atomic -> ATOMIC LCURLY stmts RCURLY
Rule 63    asgn -> varname EQLS expr SEMI
Rule 64    asgn -> varname INCR SEMI
Rule 65    mwblock -> MW LCURLY decls RCURLY
Rule 66    decls -> decl decls
Rule 67    decls -> sharedecl decls
Rule 68    decls -> enumdecl decls
Rule 69    decls -> mapdecl decls
Rule 70    decls -> empty
Rule 71    empty -> <empty>
Rule 72    decl -> type varname SEMI
Rule 73    decl -> type varname EQLS val SEMI
Rule 74    mapdecl -> MAP varname SEMI
Rule 75    enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
Rule 76    varnames -> varname COMMA varnames
Rule 77    varnames -> varname
Rule 78    sharedecl -> SHARED type varname SEMI
Rule 79    sharedecl -> SHARED type varname EQLS val SEMI
Rule 80    val -> INUM
Rule 81    val -> FNUM
Rule 82    val -> TRUE
Rule 83    val -> FALSE
Rule 84    val -> NULL
Rule 85    expr -> val
Rule 86    expr -> varname
Rule 87    expr -> expr PLUS expr
Rule 88    expr -> expr MINUS expr
Rule 89    expr -> expr TIMES expr
Rule 90    expr -> expr BY expr
Rule 91    expr -> LPAREN expr RPAREN
Rule 92    type -> INT
Rule 93    type -> FLOAT
Rule 94    type -> BOOL
Rule 95    type -> ITEMPOSITION
Rule 96    type -> OBSTACLELIST
Rule 97    varname -> LID
Rule 98    varname -> CID

Terminals, with rules where they appear

AGENT                : 2
AND                  : 18
ATOMIC               : 62
BOOL                 : 94
BR                   : 2
BY                   : 90
CID                  : 2 98
COMMA                : 52 55 61 76
DONEFLAG             : 22 50
DOREACHAVOID         : 55
EFF                  : 30
ELSE                 : 56
ENUM                 : 75
EQ                   : 24
EQLS                 : 10 42 47 63 73 75 79
EXIT                 : 9 53
FAILFLAG             : 23 51
FALSE                : 83
FLOAT                : 93
FNUM                 : 81
GE                   : 28
GEQ                  : 26
GETINPUT             : 47
GETMYPOS             : 10
IF                   : 56
INCR                 : 64
INIT                 : 3
INT                  : 92
INUM                 : 80
ISEMPTY              : 17
ITEMPOSITION         : 95
LANGLE               : 
LCURLY               : 3 8 9 30 56 56 62 65 75
LE                   : 29
LEQ                  : 27
LID                  : 97
LIST                 : 
LOG                  : 49 50 51
LPAREN               : 3 8 9 10 11 12 13 17 21 46 47 48 49 50 51 52 55 56 57 91
MAP                  : 74
MINUS                : 88
MSG                  : 48
MW                   : 65
NEQ                  : 25
NOT                  : 20
NULL                 : 84
OBSTACLELIST         : 96
OR                   : 19
PLUS                 : 87
PRE                  : 12 13
PRINTLOG             : 
QUEUE                : 
RANGLE               : 
RCURLY               : 3 8 9 30 56 56 62 65 75
REMOVE               : 52
RETURN               : 54
ROBOT                : 11
RPAREN               : 3 8 9 10 11 12 13 17 21 46 47 48 49 50 51 52 55 56 57 91
SEMI                 : 7 11 12 13 46 47 48 49 50 51 52 53 54 55 57 63 64 72 73 74 75 78 79
SHARED               : 78 79
STACK                : 
TIMES                : 89
TRUE                 : 13 82
UPDATE               : 46
error                : 

Nonterminals, with rules where they appear

agentDecl            : 1
args                 : 57
asgn                 : 33
atomic               : 36
cond                 : 12 18 18 19 19 21 56
decl                 : 66
decls                : 1 65 66 67 68 69
doreachavoid         : 43
eff                  : 8 9
empty                : 5 32 58 70
enumdecl             : 68
event                : 4
events               : 3 4
exit                 : 34
expr                 : 15 20 24 24 25 25 26 26 27 27 28 28 29 29 54 55 60 61 63 87 87 88 88 89 89 90 90 91
flag                 : 16
funcCall             : 40 42
getInput             : 41
getpos               : 7
initblock            : 1
ite                  : 35
log                  : 45
mapdecl              : 69
msg                  : 39
mwblock              : 1
neargs               : 59 61
pgm                  : 0
pre                  : 8 9
rel                  : 14
remove               : 37
return               : 44
robotinit            : 6
sharedecl            : 67
stmt                 : 31
stmts                : 30 31 56 56 62
type                 : 72 73 78 79
update               : 38
val                  : 73 79 85
varname              : 8 10 17 42 46 47 48 52 52 55 57 63 64 72 73 74 75 75 75 76 77 78 79 86
varnames             : 75 76

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . agentDecl mwblock decls initblock
    (2) agentDecl -> . AGENT BR CID

    AGENT           shift and go to state 2

    agentDecl                      shift and go to state 3
    pgm                            shift and go to state 1

state 1

    (0) S' -> pgm .



state 2

    (2) agentDecl -> AGENT . BR CID

    BR              shift and go to state 4


state 3

    (1) pgm -> agentDecl . mwblock decls initblock
    (65) mwblock -> . MW LCURLY decls RCURLY

    MW              shift and go to state 6

    mwblock                        shift and go to state 5

state 4

    (2) agentDecl -> AGENT BR . CID

    CID             shift and go to state 7


state 5

    (1) pgm -> agentDecl mwblock . decls initblock
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    INIT            reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    sharedecl                      shift and go to state 12
    decls                          shift and go to state 22
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 6

    (65) mwblock -> MW . LCURLY decls RCURLY

    LCURLY          shift and go to state 23


state 7

    (2) agentDecl -> AGENT BR CID .

    MW              reduce using rule 2 (agentDecl -> AGENT BR CID .)


state 8

    (66) decls -> decl . decls
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    INIT            reduce using rule 71 (empty -> .)
    RCURLY          reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 12
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    decls                          shift and go to state 24
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 9

    (96) type -> OBSTACLELIST .

    LID             reduce using rule 96 (type -> OBSTACLELIST .)
    CID             reduce using rule 96 (type -> OBSTACLELIST .)


state 10

    (95) type -> ITEMPOSITION .

    LID             reduce using rule 95 (type -> ITEMPOSITION .)
    CID             reduce using rule 95 (type -> ITEMPOSITION .)


state 11

    (69) decls -> mapdecl . decls
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    INIT            reduce using rule 71 (empty -> .)
    RCURLY          reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 12
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    decls                          shift and go to state 25
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 12

    (67) decls -> sharedecl . decls
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    INIT            reduce using rule 71 (empty -> .)
    RCURLY          reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 12
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    decls                          shift and go to state 26
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 13

    (72) decl -> type . varname SEMI
    (73) decl -> type . varname EQLS val SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 29

state 14

    (70) decls -> empty .

    INIT            reduce using rule 70 (decls -> empty .)
    RCURLY          reduce using rule 70 (decls -> empty .)


state 15

    (75) enumdecl -> ENUM . varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 30

state 16

    (74) mapdecl -> MAP . varname SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 31

state 17

    (92) type -> INT .

    LID             reduce using rule 92 (type -> INT .)
    CID             reduce using rule 92 (type -> INT .)


state 18

    (93) type -> FLOAT .

    LID             reduce using rule 93 (type -> FLOAT .)
    CID             reduce using rule 93 (type -> FLOAT .)


state 19

    (68) decls -> enumdecl . decls
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    INIT            reduce using rule 71 (empty -> .)
    RCURLY          reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 12
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    decls                          shift and go to state 32
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 20

    (94) type -> BOOL .

    LID             reduce using rule 94 (type -> BOOL .)
    CID             reduce using rule 94 (type -> BOOL .)


state 21

    (78) sharedecl -> SHARED . type varname SEMI
    (79) sharedecl -> SHARED . type varname EQLS val SEMI
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    type                           shift and go to state 33

state 22

    (1) pgm -> agentDecl mwblock decls . initblock
    (3) initblock -> . INIT LPAREN RPAREN LCURLY events RCURLY

    INIT            shift and go to state 35

    initblock                      shift and go to state 34

state 23

    (65) mwblock -> MW LCURLY . decls RCURLY
    (66) decls -> . decl decls
    (67) decls -> . sharedecl decls
    (68) decls -> . enumdecl decls
    (69) decls -> . mapdecl decls
    (70) decls -> . empty
    (72) decl -> . type varname SEMI
    (73) decl -> . type varname EQLS val SEMI
    (78) sharedecl -> . SHARED type varname SEMI
    (79) sharedecl -> . SHARED type varname EQLS val SEMI
    (75) enumdecl -> . ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI
    (74) mapdecl -> . MAP varname SEMI
    (71) empty -> .
    (92) type -> . INT
    (93) type -> . FLOAT
    (94) type -> . BOOL
    (95) type -> . ITEMPOSITION
    (96) type -> . OBSTACLELIST

    SHARED          shift and go to state 21
    ENUM            shift and go to state 15
    MAP             shift and go to state 16
    RCURLY          reduce using rule 71 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    BOOL            shift and go to state 20
    ITEMPOSITION    shift and go to state 10
    OBSTACLELIST    shift and go to state 9

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 12
    enumdecl                       shift and go to state 19
    mapdecl                        shift and go to state 11
    decls                          shift and go to state 36
    type                           shift and go to state 13
    empty                          shift and go to state 14

state 24

    (66) decls -> decl decls .

    INIT            reduce using rule 66 (decls -> decl decls .)
    RCURLY          reduce using rule 66 (decls -> decl decls .)


state 25

    (69) decls -> mapdecl decls .

    INIT            reduce using rule 69 (decls -> mapdecl decls .)
    RCURLY          reduce using rule 69 (decls -> mapdecl decls .)


state 26

    (67) decls -> sharedecl decls .

    INIT            reduce using rule 67 (decls -> sharedecl decls .)
    RCURLY          reduce using rule 67 (decls -> sharedecl decls .)


state 27

    (97) varname -> LID .

    LPAREN          reduce using rule 97 (varname -> LID .)
    SEMI            reduce using rule 97 (varname -> LID .)
    PLUS            reduce using rule 97 (varname -> LID .)
    MINUS           reduce using rule 97 (varname -> LID .)
    TIMES           reduce using rule 97 (varname -> LID .)
    BY              reduce using rule 97 (varname -> LID .)
    RPAREN          reduce using rule 97 (varname -> LID .)
    AND             reduce using rule 97 (varname -> LID .)
    OR              reduce using rule 97 (varname -> LID .)
    EQLS            reduce using rule 97 (varname -> LID .)
    EQ              reduce using rule 97 (varname -> LID .)
    NEQ             reduce using rule 97 (varname -> LID .)
    GEQ             reduce using rule 97 (varname -> LID .)
    LEQ             reduce using rule 97 (varname -> LID .)
    GE              reduce using rule 97 (varname -> LID .)
    LE              reduce using rule 97 (varname -> LID .)
    COMMA           reduce using rule 97 (varname -> LID .)
    RCURLY          reduce using rule 97 (varname -> LID .)
    INCR            reduce using rule 97 (varname -> LID .)
    LCURLY          reduce using rule 97 (varname -> LID .)


state 28

    (98) varname -> CID .

    LPAREN          reduce using rule 98 (varname -> CID .)
    SEMI            reduce using rule 98 (varname -> CID .)
    PLUS            reduce using rule 98 (varname -> CID .)
    MINUS           reduce using rule 98 (varname -> CID .)
    TIMES           reduce using rule 98 (varname -> CID .)
    BY              reduce using rule 98 (varname -> CID .)
    RPAREN          reduce using rule 98 (varname -> CID .)
    AND             reduce using rule 98 (varname -> CID .)
    OR              reduce using rule 98 (varname -> CID .)
    EQLS            reduce using rule 98 (varname -> CID .)
    EQ              reduce using rule 98 (varname -> CID .)
    NEQ             reduce using rule 98 (varname -> CID .)
    GEQ             reduce using rule 98 (varname -> CID .)
    LEQ             reduce using rule 98 (varname -> CID .)
    GE              reduce using rule 98 (varname -> CID .)
    LE              reduce using rule 98 (varname -> CID .)
    COMMA           reduce using rule 98 (varname -> CID .)
    RCURLY          reduce using rule 98 (varname -> CID .)
    INCR            reduce using rule 98 (varname -> CID .)
    LCURLY          reduce using rule 98 (varname -> CID .)


state 29

    (72) decl -> type varname . SEMI
    (73) decl -> type varname . EQLS val SEMI

    SEMI            shift and go to state 38
    EQLS            shift and go to state 37


state 30

    (75) enumdecl -> ENUM varname . LCURLY varnames RCURLY varname EQLS varname SEMI

    LCURLY          shift and go to state 39


state 31

    (74) mapdecl -> MAP varname . SEMI

    SEMI            shift and go to state 40


state 32

    (68) decls -> enumdecl decls .

    INIT            reduce using rule 68 (decls -> enumdecl decls .)
    RCURLY          reduce using rule 68 (decls -> enumdecl decls .)


state 33

    (78) sharedecl -> SHARED type . varname SEMI
    (79) sharedecl -> SHARED type . varname EQLS val SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 41

state 34

    (1) pgm -> agentDecl mwblock decls initblock .

    $end            reduce using rule 1 (pgm -> agentDecl mwblock decls initblock .)


state 35

    (3) initblock -> INIT . LPAREN RPAREN LCURLY events RCURLY

    LPAREN          shift and go to state 42


state 36

    (65) mwblock -> MW LCURLY decls . RCURLY

    RCURLY          shift and go to state 43


state 37

    (73) decl -> type varname EQLS . val SEMI
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL

    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48

    val                            shift and go to state 45

state 38

    (72) decl -> type varname SEMI .

    SHARED          reduce using rule 72 (decl -> type varname SEMI .)
    ENUM            reduce using rule 72 (decl -> type varname SEMI .)
    MAP             reduce using rule 72 (decl -> type varname SEMI .)
    INT             reduce using rule 72 (decl -> type varname SEMI .)
    FLOAT           reduce using rule 72 (decl -> type varname SEMI .)
    BOOL            reduce using rule 72 (decl -> type varname SEMI .)
    ITEMPOSITION    reduce using rule 72 (decl -> type varname SEMI .)
    OBSTACLELIST    reduce using rule 72 (decl -> type varname SEMI .)
    INIT            reduce using rule 72 (decl -> type varname SEMI .)
    RCURLY          reduce using rule 72 (decl -> type varname SEMI .)


state 39

    (75) enumdecl -> ENUM varname LCURLY . varnames RCURLY varname EQLS varname SEMI
    (76) varnames -> . varname COMMA varnames
    (77) varnames -> . varname
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 50
    varnames                       shift and go to state 51

state 40

    (74) mapdecl -> MAP varname SEMI .

    SHARED          reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    ENUM            reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    MAP             reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    INT             reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    FLOAT           reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    BOOL            reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    ITEMPOSITION    reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    OBSTACLELIST    reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    INIT            reduce using rule 74 (mapdecl -> MAP varname SEMI .)
    RCURLY          reduce using rule 74 (mapdecl -> MAP varname SEMI .)


state 41

    (78) sharedecl -> SHARED type varname . SEMI
    (79) sharedecl -> SHARED type varname . EQLS val SEMI

    SEMI            shift and go to state 52
    EQLS            shift and go to state 53


state 42

    (3) initblock -> INIT LPAREN . RPAREN LCURLY events RCURLY

    RPAREN          shift and go to state 54


state 43

    (65) mwblock -> MW LCURLY decls RCURLY .

    SHARED          reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    ENUM            reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    MAP             reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    INT             reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    FLOAT           reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    BOOL            reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    ITEMPOSITION    reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    OBSTACLELIST    reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)
    INIT            reduce using rule 65 (mwblock -> MW LCURLY decls RCURLY .)


state 44

    (83) val -> FALSE .

    SEMI            reduce using rule 83 (val -> FALSE .)
    PLUS            reduce using rule 83 (val -> FALSE .)
    MINUS           reduce using rule 83 (val -> FALSE .)
    TIMES           reduce using rule 83 (val -> FALSE .)
    BY              reduce using rule 83 (val -> FALSE .)
    EQ              reduce using rule 83 (val -> FALSE .)
    NEQ             reduce using rule 83 (val -> FALSE .)
    GEQ             reduce using rule 83 (val -> FALSE .)
    LEQ             reduce using rule 83 (val -> FALSE .)
    GE              reduce using rule 83 (val -> FALSE .)
    LE              reduce using rule 83 (val -> FALSE .)
    AND             reduce using rule 83 (val -> FALSE .)
    OR              reduce using rule 83 (val -> FALSE .)
    RPAREN          reduce using rule 83 (val -> FALSE .)
    COMMA           reduce using rule 83 (val -> FALSE .)


state 45

    (73) decl -> type varname EQLS val . SEMI

    SEMI            shift and go to state 55


state 46

    (81) val -> FNUM .

    SEMI            reduce using rule 81 (val -> FNUM .)
    PLUS            reduce using rule 81 (val -> FNUM .)
    MINUS           reduce using rule 81 (val -> FNUM .)
    TIMES           reduce using rule 81 (val -> FNUM .)
    BY              reduce using rule 81 (val -> FNUM .)
    EQ              reduce using rule 81 (val -> FNUM .)
    NEQ             reduce using rule 81 (val -> FNUM .)
    GEQ             reduce using rule 81 (val -> FNUM .)
    LEQ             reduce using rule 81 (val -> FNUM .)
    GE              reduce using rule 81 (val -> FNUM .)
    LE              reduce using rule 81 (val -> FNUM .)
    AND             reduce using rule 81 (val -> FNUM .)
    OR              reduce using rule 81 (val -> FNUM .)
    RPAREN          reduce using rule 81 (val -> FNUM .)
    COMMA           reduce using rule 81 (val -> FNUM .)


state 47

    (80) val -> INUM .

    SEMI            reduce using rule 80 (val -> INUM .)
    PLUS            reduce using rule 80 (val -> INUM .)
    MINUS           reduce using rule 80 (val -> INUM .)
    TIMES           reduce using rule 80 (val -> INUM .)
    BY              reduce using rule 80 (val -> INUM .)
    EQ              reduce using rule 80 (val -> INUM .)
    NEQ             reduce using rule 80 (val -> INUM .)
    GEQ             reduce using rule 80 (val -> INUM .)
    LEQ             reduce using rule 80 (val -> INUM .)
    GE              reduce using rule 80 (val -> INUM .)
    LE              reduce using rule 80 (val -> INUM .)
    AND             reduce using rule 80 (val -> INUM .)
    OR              reduce using rule 80 (val -> INUM .)
    RPAREN          reduce using rule 80 (val -> INUM .)
    COMMA           reduce using rule 80 (val -> INUM .)


state 48

    (84) val -> NULL .

    SEMI            reduce using rule 84 (val -> NULL .)
    PLUS            reduce using rule 84 (val -> NULL .)
    MINUS           reduce using rule 84 (val -> NULL .)
    TIMES           reduce using rule 84 (val -> NULL .)
    BY              reduce using rule 84 (val -> NULL .)
    EQ              reduce using rule 84 (val -> NULL .)
    NEQ             reduce using rule 84 (val -> NULL .)
    GEQ             reduce using rule 84 (val -> NULL .)
    LEQ             reduce using rule 84 (val -> NULL .)
    GE              reduce using rule 84 (val -> NULL .)
    LE              reduce using rule 84 (val -> NULL .)
    AND             reduce using rule 84 (val -> NULL .)
    OR              reduce using rule 84 (val -> NULL .)
    RPAREN          reduce using rule 84 (val -> NULL .)
    COMMA           reduce using rule 84 (val -> NULL .)


state 49

    (82) val -> TRUE .

    SEMI            reduce using rule 82 (val -> TRUE .)
    PLUS            reduce using rule 82 (val -> TRUE .)
    MINUS           reduce using rule 82 (val -> TRUE .)
    TIMES           reduce using rule 82 (val -> TRUE .)
    BY              reduce using rule 82 (val -> TRUE .)
    EQ              reduce using rule 82 (val -> TRUE .)
    NEQ             reduce using rule 82 (val -> TRUE .)
    GEQ             reduce using rule 82 (val -> TRUE .)
    LEQ             reduce using rule 82 (val -> TRUE .)
    GE              reduce using rule 82 (val -> TRUE .)
    LE              reduce using rule 82 (val -> TRUE .)
    AND             reduce using rule 82 (val -> TRUE .)
    OR              reduce using rule 82 (val -> TRUE .)
    RPAREN          reduce using rule 82 (val -> TRUE .)
    COMMA           reduce using rule 82 (val -> TRUE .)


state 50

    (76) varnames -> varname . COMMA varnames
    (77) varnames -> varname .

    COMMA           shift and go to state 56
    RCURLY          reduce using rule 77 (varnames -> varname .)


state 51

    (75) enumdecl -> ENUM varname LCURLY varnames . RCURLY varname EQLS varname SEMI

    RCURLY          shift and go to state 57


state 52

    (78) sharedecl -> SHARED type varname SEMI .

    SHARED          reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    ENUM            reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    MAP             reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    INT             reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    FLOAT           reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    BOOL            reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    ITEMPOSITION    reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    OBSTACLELIST    reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    INIT            reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)
    RCURLY          reduce using rule 78 (sharedecl -> SHARED type varname SEMI .)


state 53

    (79) sharedecl -> SHARED type varname EQLS . val SEMI
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL

    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48

    val                            shift and go to state 58

state 54

    (3) initblock -> INIT LPAREN RPAREN . LCURLY events RCURLY

    LCURLY          shift and go to state 59


state 55

    (73) decl -> type varname EQLS val SEMI .

    SHARED          reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    ENUM            reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    MAP             reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    INT             reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    FLOAT           reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    BOOL            reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    ITEMPOSITION    reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    OBSTACLELIST    reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    INIT            reduce using rule 73 (decl -> type varname EQLS val SEMI .)
    RCURLY          reduce using rule 73 (decl -> type varname EQLS val SEMI .)


state 56

    (76) varnames -> varname COMMA . varnames
    (76) varnames -> . varname COMMA varnames
    (77) varnames -> . varname
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 50
    varnames                       shift and go to state 60

state 57

    (75) enumdecl -> ENUM varname LCURLY varnames RCURLY . varname EQLS varname SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 61

state 58

    (79) sharedecl -> SHARED type varname EQLS val . SEMI

    SEMI            shift and go to state 62


state 59

    (3) initblock -> INIT LPAREN RPAREN LCURLY . events RCURLY
    (4) events -> . event events
    (5) events -> . empty
    (6) event -> . robotinit
    (7) event -> . getpos SEMI
    (8) event -> . varname LPAREN RPAREN LCURLY pre eff RCURLY
    (9) event -> . EXIT LPAREN RPAREN LCURLY pre eff RCURLY
    (71) empty -> .
    (11) robotinit -> . ROBOT LPAREN RPAREN SEMI
    (10) getpos -> . varname EQLS GETMYPOS LPAREN RPAREN
    (97) varname -> . LID
    (98) varname -> . CID

    EXIT            shift and go to state 67
    RCURLY          reduce using rule 71 (empty -> .)
    ROBOT           shift and go to state 65
    LID             shift and go to state 27
    CID             shift and go to state 28

    getpos                         shift and go to state 68
    robotinit                      shift and go to state 64
    varname                        shift and go to state 63
    event                          shift and go to state 66
    events                         shift and go to state 69
    empty                          shift and go to state 70

state 60

    (76) varnames -> varname COMMA varnames .

    RCURLY          reduce using rule 76 (varnames -> varname COMMA varnames .)


state 61

    (75) enumdecl -> ENUM varname LCURLY varnames RCURLY varname . EQLS varname SEMI

    EQLS            shift and go to state 71


state 62

    (79) sharedecl -> SHARED type varname EQLS val SEMI .

    SHARED          reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    ENUM            reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    MAP             reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    INT             reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    FLOAT           reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    BOOL            reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    ITEMPOSITION    reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    OBSTACLELIST    reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    INIT            reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)
    RCURLY          reduce using rule 79 (sharedecl -> SHARED type varname EQLS val SEMI .)


state 63

    (8) event -> varname . LPAREN RPAREN LCURLY pre eff RCURLY
    (10) getpos -> varname . EQLS GETMYPOS LPAREN RPAREN

    LPAREN          shift and go to state 73
    EQLS            shift and go to state 72


state 64

    (6) event -> robotinit .

    EXIT            reduce using rule 6 (event -> robotinit .)
    ROBOT           reduce using rule 6 (event -> robotinit .)
    LID             reduce using rule 6 (event -> robotinit .)
    CID             reduce using rule 6 (event -> robotinit .)
    RCURLY          reduce using rule 6 (event -> robotinit .)


state 65

    (11) robotinit -> ROBOT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 74


state 66

    (4) events -> event . events
    (4) events -> . event events
    (5) events -> . empty
    (6) event -> . robotinit
    (7) event -> . getpos SEMI
    (8) event -> . varname LPAREN RPAREN LCURLY pre eff RCURLY
    (9) event -> . EXIT LPAREN RPAREN LCURLY pre eff RCURLY
    (71) empty -> .
    (11) robotinit -> . ROBOT LPAREN RPAREN SEMI
    (10) getpos -> . varname EQLS GETMYPOS LPAREN RPAREN
    (97) varname -> . LID
    (98) varname -> . CID

    EXIT            shift and go to state 67
    RCURLY          reduce using rule 71 (empty -> .)
    ROBOT           shift and go to state 65
    LID             shift and go to state 27
    CID             shift and go to state 28

    getpos                         shift and go to state 68
    robotinit                      shift and go to state 64
    varname                        shift and go to state 63
    events                         shift and go to state 75
    event                          shift and go to state 66
    empty                          shift and go to state 70

state 67

    (9) event -> EXIT . LPAREN RPAREN LCURLY pre eff RCURLY

    LPAREN          shift and go to state 76


state 68

    (7) event -> getpos . SEMI

    SEMI            shift and go to state 77


state 69

    (3) initblock -> INIT LPAREN RPAREN LCURLY events . RCURLY

    RCURLY          shift and go to state 78


state 70

    (5) events -> empty .

    RCURLY          reduce using rule 5 (events -> empty .)


state 71

    (75) enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS . varname SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 79

state 72

    (10) getpos -> varname EQLS . GETMYPOS LPAREN RPAREN

    GETMYPOS        shift and go to state 80


state 73

    (8) event -> varname LPAREN . RPAREN LCURLY pre eff RCURLY

    RPAREN          shift and go to state 81


state 74

    (11) robotinit -> ROBOT LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 82


state 75

    (4) events -> event events .

    RCURLY          reduce using rule 4 (events -> event events .)


state 76

    (9) event -> EXIT LPAREN . RPAREN LCURLY pre eff RCURLY

    RPAREN          shift and go to state 83


state 77

    (7) event -> getpos SEMI .

    EXIT            reduce using rule 7 (event -> getpos SEMI .)
    ROBOT           reduce using rule 7 (event -> getpos SEMI .)
    LID             reduce using rule 7 (event -> getpos SEMI .)
    CID             reduce using rule 7 (event -> getpos SEMI .)
    RCURLY          reduce using rule 7 (event -> getpos SEMI .)


state 78

    (3) initblock -> INIT LPAREN RPAREN LCURLY events RCURLY .

    $end            reduce using rule 3 (initblock -> INIT LPAREN RPAREN LCURLY events RCURLY .)


state 79

    (75) enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname . SEMI

    SEMI            shift and go to state 84


state 80

    (10) getpos -> varname EQLS GETMYPOS . LPAREN RPAREN

    LPAREN          shift and go to state 85


state 81

    (8) event -> varname LPAREN RPAREN . LCURLY pre eff RCURLY

    LCURLY          shift and go to state 86


state 82

    (11) robotinit -> ROBOT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 87


state 83

    (9) event -> EXIT LPAREN RPAREN . LCURLY pre eff RCURLY

    LCURLY          shift and go to state 88


state 84

    (75) enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .

    SHARED          reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    ENUM            reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    MAP             reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    INT             reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    FLOAT           reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    BOOL            reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    ITEMPOSITION    reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    OBSTACLELIST    reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    INIT            reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)
    RCURLY          reduce using rule 75 (enumdecl -> ENUM varname LCURLY varnames RCURLY varname EQLS varname SEMI .)


state 85

    (10) getpos -> varname EQLS GETMYPOS LPAREN . RPAREN

    RPAREN          shift and go to state 89


state 86

    (8) event -> varname LPAREN RPAREN LCURLY . pre eff RCURLY
    (12) pre -> . PRE LPAREN cond RPAREN SEMI
    (13) pre -> . PRE LPAREN TRUE RPAREN SEMI

    PRE             shift and go to state 91

    pre                            shift and go to state 90

state 87

    (11) robotinit -> ROBOT LPAREN RPAREN SEMI .

    EXIT            reduce using rule 11 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    ROBOT           reduce using rule 11 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    LID             reduce using rule 11 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    CID             reduce using rule 11 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    RCURLY          reduce using rule 11 (robotinit -> ROBOT LPAREN RPAREN SEMI .)


state 88

    (9) event -> EXIT LPAREN RPAREN LCURLY . pre eff RCURLY
    (12) pre -> . PRE LPAREN cond RPAREN SEMI
    (13) pre -> . PRE LPAREN TRUE RPAREN SEMI

    PRE             shift and go to state 91

    pre                            shift and go to state 92

state 89

    (10) getpos -> varname EQLS GETMYPOS LPAREN RPAREN .

    SEMI            reduce using rule 10 (getpos -> varname EQLS GETMYPOS LPAREN RPAREN .)


state 90

    (8) event -> varname LPAREN RPAREN LCURLY pre . eff RCURLY
    (30) eff -> . EFF LCURLY stmts RCURLY

    EFF             shift and go to state 93

    eff                            shift and go to state 94

state 91

    (12) pre -> PRE . LPAREN cond RPAREN SEMI
    (13) pre -> PRE . LPAREN TRUE RPAREN SEMI

    LPAREN          shift and go to state 95


state 92

    (9) event -> EXIT LPAREN RPAREN LCURLY pre . eff RCURLY
    (30) eff -> . EFF LCURLY stmts RCURLY

    EFF             shift and go to state 93

    eff                            shift and go to state 96

state 93

    (30) eff -> EFF . LCURLY stmts RCURLY

    LCURLY          shift and go to state 97


state 94

    (8) event -> varname LPAREN RPAREN LCURLY pre eff . RCURLY

    RCURLY          shift and go to state 98


state 95

    (12) pre -> PRE LPAREN . cond RPAREN SEMI
    (13) pre -> PRE LPAREN . TRUE RPAREN SEMI
    (14) cond -> . rel
    (15) cond -> . expr
    (16) cond -> . flag
    (17) cond -> . ISEMPTY LPAREN varname RPAREN
    (18) cond -> . cond AND cond
    (19) cond -> . cond OR cond
    (20) cond -> . NOT expr
    (21) cond -> . LPAREN cond RPAREN
    (24) rel -> . expr EQ expr
    (25) rel -> . expr NEQ expr
    (26) rel -> . expr GEQ expr
    (27) rel -> . expr LEQ expr
    (28) rel -> . expr GE expr
    (29) rel -> . expr LE expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (22) flag -> . DONEFLAG
    (23) flag -> . FAILFLAG
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    TRUE            shift and go to state 100
    ISEMPTY         shift and go to state 102
    NOT             shift and go to state 110
    LPAREN          shift and go to state 104
    DONEFLAG        shift and go to state 108
    FAILFLAG        shift and go to state 103
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    expr                           shift and go to state 106
    flag                           shift and go to state 107
    cond                           shift and go to state 99
    rel                            shift and go to state 101
    varname                        shift and go to state 109

state 96

    (9) event -> EXIT LPAREN RPAREN LCURLY pre eff . RCURLY

    RCURLY          shift and go to state 111


state 97

    (30) eff -> EFF LCURLY . stmts RCURLY
    (31) stmts -> . stmt stmts
    (32) stmts -> . empty
    (33) stmt -> . asgn
    (34) stmt -> . exit
    (35) stmt -> . ite
    (36) stmt -> . atomic
    (37) stmt -> . remove
    (38) stmt -> . update
    (39) stmt -> . msg
    (40) stmt -> . funcCall
    (41) stmt -> . getInput
    (42) stmt -> . varname EQLS funcCall
    (43) stmt -> . doreachavoid
    (44) stmt -> . return
    (45) stmt -> . log
    (71) empty -> .
    (63) asgn -> . varname EQLS expr SEMI
    (64) asgn -> . varname INCR SEMI
    (53) exit -> . EXIT SEMI
    (56) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (62) atomic -> . ATOMIC LCURLY stmts RCURLY
    (52) remove -> . REMOVE LPAREN varname COMMA varname RPAREN SEMI
    (46) update -> . UPDATE LPAREN varname RPAREN SEMI
    (48) msg -> . MSG LPAREN varname RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (47) getInput -> . varname EQLS GETINPUT LPAREN RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID
    (55) doreachavoid -> . DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
    (54) return -> . RETURN expr SEMI
    (49) log -> . LOG LPAREN RPAREN SEMI
    (50) log -> . LOG LPAREN DONEFLAG RPAREN SEMI
    (51) log -> . LOG LPAREN FAILFLAG RPAREN SEMI

    RCURLY          reduce using rule 71 (empty -> .)
    EXIT            shift and go to state 135
    IF              shift and go to state 129
    ATOMIC          shift and go to state 136
    REMOVE          shift and go to state 130
    UPDATE          shift and go to state 131
    MSG             shift and go to state 128
    LID             shift and go to state 27
    CID             shift and go to state 28
    DOREACHAVOID    shift and go to state 114
    RETURN          shift and go to state 112
    LOG             shift and go to state 113

    return                         shift and go to state 125
    log                            shift and go to state 119
    funcCall                       shift and go to state 132
    stmts                          shift and go to state 120
    varname                        shift and go to state 133
    update                         shift and go to state 126
    ite                            shift and go to state 115
    remove                         shift and go to state 134
    stmt                           shift and go to state 127
    asgn                           shift and go to state 121
    getInput                       shift and go to state 117
    exit                           shift and go to state 122
    atomic                         shift and go to state 116
    msg                            shift and go to state 123
    doreachavoid                   shift and go to state 118
    empty                          shift and go to state 124

state 98

    (8) event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .

    EXIT            reduce using rule 8 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    ROBOT           reduce using rule 8 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    LID             reduce using rule 8 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    CID             reduce using rule 8 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    RCURLY          reduce using rule 8 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)


state 99

    (12) pre -> PRE LPAREN cond . RPAREN SEMI
    (18) cond -> cond . AND cond
    (19) cond -> cond . OR cond

    RPAREN          shift and go to state 138
    AND             shift and go to state 137
    OR              shift and go to state 139


state 100

    (13) pre -> PRE LPAREN TRUE . RPAREN SEMI
    (82) val -> TRUE .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 140
    EQ              reduce using rule 82 (val -> TRUE .)
    NEQ             reduce using rule 82 (val -> TRUE .)
    GEQ             reduce using rule 82 (val -> TRUE .)
    LEQ             reduce using rule 82 (val -> TRUE .)
    GE              reduce using rule 82 (val -> TRUE .)
    LE              reduce using rule 82 (val -> TRUE .)
    PLUS            reduce using rule 82 (val -> TRUE .)
    MINUS           reduce using rule 82 (val -> TRUE .)
    TIMES           reduce using rule 82 (val -> TRUE .)
    BY              reduce using rule 82 (val -> TRUE .)
    AND             reduce using rule 82 (val -> TRUE .)
    OR              reduce using rule 82 (val -> TRUE .)

  ! RPAREN          [ reduce using rule 82 (val -> TRUE .) ]


state 101

    (14) cond -> rel .

    RPAREN          reduce using rule 14 (cond -> rel .)
    AND             reduce using rule 14 (cond -> rel .)
    OR              reduce using rule 14 (cond -> rel .)


state 102

    (17) cond -> ISEMPTY . LPAREN varname RPAREN

    LPAREN          shift and go to state 141


state 103

    (23) flag -> FAILFLAG .

    RPAREN          reduce using rule 23 (flag -> FAILFLAG .)
    AND             reduce using rule 23 (flag -> FAILFLAG .)
    OR              reduce using rule 23 (flag -> FAILFLAG .)


state 104

    (21) cond -> LPAREN . cond RPAREN
    (91) expr -> LPAREN . expr RPAREN
    (14) cond -> . rel
    (15) cond -> . expr
    (16) cond -> . flag
    (17) cond -> . ISEMPTY LPAREN varname RPAREN
    (18) cond -> . cond AND cond
    (19) cond -> . cond OR cond
    (20) cond -> . NOT expr
    (21) cond -> . LPAREN cond RPAREN
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (24) rel -> . expr EQ expr
    (25) rel -> . expr NEQ expr
    (26) rel -> . expr GEQ expr
    (27) rel -> . expr LEQ expr
    (28) rel -> . expr GE expr
    (29) rel -> . expr LE expr
    (22) flag -> . DONEFLAG
    (23) flag -> . FAILFLAG
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    ISEMPTY         shift and go to state 102
    NOT             shift and go to state 110
    LPAREN          shift and go to state 104
    DONEFLAG        shift and go to state 108
    FAILFLAG        shift and go to state 103
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    expr                           shift and go to state 143
    flag                           shift and go to state 107
    cond                           shift and go to state 142
    rel                            shift and go to state 101
    varname                        shift and go to state 109

state 105

    (85) expr -> val .

    RPAREN          reduce using rule 85 (expr -> val .)
    PLUS            reduce using rule 85 (expr -> val .)
    MINUS           reduce using rule 85 (expr -> val .)
    TIMES           reduce using rule 85 (expr -> val .)
    BY              reduce using rule 85 (expr -> val .)
    EQ              reduce using rule 85 (expr -> val .)
    NEQ             reduce using rule 85 (expr -> val .)
    GEQ             reduce using rule 85 (expr -> val .)
    LEQ             reduce using rule 85 (expr -> val .)
    GE              reduce using rule 85 (expr -> val .)
    LE              reduce using rule 85 (expr -> val .)
    AND             reduce using rule 85 (expr -> val .)
    OR              reduce using rule 85 (expr -> val .)
    SEMI            reduce using rule 85 (expr -> val .)
    COMMA           reduce using rule 85 (expr -> val .)


state 106

    (15) cond -> expr .
    (24) rel -> expr . EQ expr
    (25) rel -> expr . NEQ expr
    (26) rel -> expr . GEQ expr
    (27) rel -> expr . LEQ expr
    (28) rel -> expr . GE expr
    (29) rel -> expr . LE expr
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 15 (cond -> expr .)
    AND             reduce using rule 15 (cond -> expr .)
    OR              reduce using rule 15 (cond -> expr .)
    EQ              shift and go to state 151
    NEQ             shift and go to state 153
    GEQ             shift and go to state 144
    LEQ             shift and go to state 148
    GE              shift and go to state 149
    LE              shift and go to state 145
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 107

    (16) cond -> flag .

    RPAREN          reduce using rule 16 (cond -> flag .)
    AND             reduce using rule 16 (cond -> flag .)
    OR              reduce using rule 16 (cond -> flag .)


state 108

    (22) flag -> DONEFLAG .

    RPAREN          reduce using rule 22 (flag -> DONEFLAG .)
    AND             reduce using rule 22 (flag -> DONEFLAG .)
    OR              reduce using rule 22 (flag -> DONEFLAG .)


state 109

    (86) expr -> varname .

    RPAREN          reduce using rule 86 (expr -> varname .)
    PLUS            reduce using rule 86 (expr -> varname .)
    MINUS           reduce using rule 86 (expr -> varname .)
    TIMES           reduce using rule 86 (expr -> varname .)
    BY              reduce using rule 86 (expr -> varname .)
    EQ              reduce using rule 86 (expr -> varname .)
    NEQ             reduce using rule 86 (expr -> varname .)
    GEQ             reduce using rule 86 (expr -> varname .)
    LEQ             reduce using rule 86 (expr -> varname .)
    GE              reduce using rule 86 (expr -> varname .)
    LE              reduce using rule 86 (expr -> varname .)
    AND             reduce using rule 86 (expr -> varname .)
    OR              reduce using rule 86 (expr -> varname .)
    SEMI            reduce using rule 86 (expr -> varname .)
    COMMA           reduce using rule 86 (expr -> varname .)


state 110

    (20) cond -> NOT . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 154
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 111

    (9) event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .

    EXIT            reduce using rule 9 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    ROBOT           reduce using rule 9 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    LID             reduce using rule 9 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    CID             reduce using rule 9 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    RCURLY          reduce using rule 9 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)


state 112

    (54) return -> RETURN . expr SEMI
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 156
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 113

    (49) log -> LOG . LPAREN RPAREN SEMI
    (50) log -> LOG . LPAREN DONEFLAG RPAREN SEMI
    (51) log -> LOG . LPAREN FAILFLAG RPAREN SEMI

    LPAREN          shift and go to state 157


state 114

    (55) doreachavoid -> DOREACHAVOID . LPAREN varname COMMA expr RPAREN SEMI

    LPAREN          shift and go to state 158


state 115

    (35) stmt -> ite .

    EXIT            reduce using rule 35 (stmt -> ite .)
    IF              reduce using rule 35 (stmt -> ite .)
    ATOMIC          reduce using rule 35 (stmt -> ite .)
    REMOVE          reduce using rule 35 (stmt -> ite .)
    UPDATE          reduce using rule 35 (stmt -> ite .)
    MSG             reduce using rule 35 (stmt -> ite .)
    LID             reduce using rule 35 (stmt -> ite .)
    CID             reduce using rule 35 (stmt -> ite .)
    DOREACHAVOID    reduce using rule 35 (stmt -> ite .)
    RETURN          reduce using rule 35 (stmt -> ite .)
    LOG             reduce using rule 35 (stmt -> ite .)
    RCURLY          reduce using rule 35 (stmt -> ite .)


state 116

    (36) stmt -> atomic .

    EXIT            reduce using rule 36 (stmt -> atomic .)
    IF              reduce using rule 36 (stmt -> atomic .)
    ATOMIC          reduce using rule 36 (stmt -> atomic .)
    REMOVE          reduce using rule 36 (stmt -> atomic .)
    UPDATE          reduce using rule 36 (stmt -> atomic .)
    MSG             reduce using rule 36 (stmt -> atomic .)
    LID             reduce using rule 36 (stmt -> atomic .)
    CID             reduce using rule 36 (stmt -> atomic .)
    DOREACHAVOID    reduce using rule 36 (stmt -> atomic .)
    RETURN          reduce using rule 36 (stmt -> atomic .)
    LOG             reduce using rule 36 (stmt -> atomic .)
    RCURLY          reduce using rule 36 (stmt -> atomic .)


state 117

    (41) stmt -> getInput .

    EXIT            reduce using rule 41 (stmt -> getInput .)
    IF              reduce using rule 41 (stmt -> getInput .)
    ATOMIC          reduce using rule 41 (stmt -> getInput .)
    REMOVE          reduce using rule 41 (stmt -> getInput .)
    UPDATE          reduce using rule 41 (stmt -> getInput .)
    MSG             reduce using rule 41 (stmt -> getInput .)
    LID             reduce using rule 41 (stmt -> getInput .)
    CID             reduce using rule 41 (stmt -> getInput .)
    DOREACHAVOID    reduce using rule 41 (stmt -> getInput .)
    RETURN          reduce using rule 41 (stmt -> getInput .)
    LOG             reduce using rule 41 (stmt -> getInput .)
    RCURLY          reduce using rule 41 (stmt -> getInput .)


state 118

    (43) stmt -> doreachavoid .

    EXIT            reduce using rule 43 (stmt -> doreachavoid .)
    IF              reduce using rule 43 (stmt -> doreachavoid .)
    ATOMIC          reduce using rule 43 (stmt -> doreachavoid .)
    REMOVE          reduce using rule 43 (stmt -> doreachavoid .)
    UPDATE          reduce using rule 43 (stmt -> doreachavoid .)
    MSG             reduce using rule 43 (stmt -> doreachavoid .)
    LID             reduce using rule 43 (stmt -> doreachavoid .)
    CID             reduce using rule 43 (stmt -> doreachavoid .)
    DOREACHAVOID    reduce using rule 43 (stmt -> doreachavoid .)
    RETURN          reduce using rule 43 (stmt -> doreachavoid .)
    LOG             reduce using rule 43 (stmt -> doreachavoid .)
    RCURLY          reduce using rule 43 (stmt -> doreachavoid .)


state 119

    (45) stmt -> log .

    EXIT            reduce using rule 45 (stmt -> log .)
    IF              reduce using rule 45 (stmt -> log .)
    ATOMIC          reduce using rule 45 (stmt -> log .)
    REMOVE          reduce using rule 45 (stmt -> log .)
    UPDATE          reduce using rule 45 (stmt -> log .)
    MSG             reduce using rule 45 (stmt -> log .)
    LID             reduce using rule 45 (stmt -> log .)
    CID             reduce using rule 45 (stmt -> log .)
    DOREACHAVOID    reduce using rule 45 (stmt -> log .)
    RETURN          reduce using rule 45 (stmt -> log .)
    LOG             reduce using rule 45 (stmt -> log .)
    RCURLY          reduce using rule 45 (stmt -> log .)


state 120

    (30) eff -> EFF LCURLY stmts . RCURLY

    RCURLY          shift and go to state 159


state 121

    (33) stmt -> asgn .

    EXIT            reduce using rule 33 (stmt -> asgn .)
    IF              reduce using rule 33 (stmt -> asgn .)
    ATOMIC          reduce using rule 33 (stmt -> asgn .)
    REMOVE          reduce using rule 33 (stmt -> asgn .)
    UPDATE          reduce using rule 33 (stmt -> asgn .)
    MSG             reduce using rule 33 (stmt -> asgn .)
    LID             reduce using rule 33 (stmt -> asgn .)
    CID             reduce using rule 33 (stmt -> asgn .)
    DOREACHAVOID    reduce using rule 33 (stmt -> asgn .)
    RETURN          reduce using rule 33 (stmt -> asgn .)
    LOG             reduce using rule 33 (stmt -> asgn .)
    RCURLY          reduce using rule 33 (stmt -> asgn .)


state 122

    (34) stmt -> exit .

    EXIT            reduce using rule 34 (stmt -> exit .)
    IF              reduce using rule 34 (stmt -> exit .)
    ATOMIC          reduce using rule 34 (stmt -> exit .)
    REMOVE          reduce using rule 34 (stmt -> exit .)
    UPDATE          reduce using rule 34 (stmt -> exit .)
    MSG             reduce using rule 34 (stmt -> exit .)
    LID             reduce using rule 34 (stmt -> exit .)
    CID             reduce using rule 34 (stmt -> exit .)
    DOREACHAVOID    reduce using rule 34 (stmt -> exit .)
    RETURN          reduce using rule 34 (stmt -> exit .)
    LOG             reduce using rule 34 (stmt -> exit .)
    RCURLY          reduce using rule 34 (stmt -> exit .)


state 123

    (39) stmt -> msg .

    EXIT            reduce using rule 39 (stmt -> msg .)
    IF              reduce using rule 39 (stmt -> msg .)
    ATOMIC          reduce using rule 39 (stmt -> msg .)
    REMOVE          reduce using rule 39 (stmt -> msg .)
    UPDATE          reduce using rule 39 (stmt -> msg .)
    MSG             reduce using rule 39 (stmt -> msg .)
    LID             reduce using rule 39 (stmt -> msg .)
    CID             reduce using rule 39 (stmt -> msg .)
    DOREACHAVOID    reduce using rule 39 (stmt -> msg .)
    RETURN          reduce using rule 39 (stmt -> msg .)
    LOG             reduce using rule 39 (stmt -> msg .)
    RCURLY          reduce using rule 39 (stmt -> msg .)


state 124

    (32) stmts -> empty .

    RCURLY          reduce using rule 32 (stmts -> empty .)


state 125

    (44) stmt -> return .

    EXIT            reduce using rule 44 (stmt -> return .)
    IF              reduce using rule 44 (stmt -> return .)
    ATOMIC          reduce using rule 44 (stmt -> return .)
    REMOVE          reduce using rule 44 (stmt -> return .)
    UPDATE          reduce using rule 44 (stmt -> return .)
    MSG             reduce using rule 44 (stmt -> return .)
    LID             reduce using rule 44 (stmt -> return .)
    CID             reduce using rule 44 (stmt -> return .)
    DOREACHAVOID    reduce using rule 44 (stmt -> return .)
    RETURN          reduce using rule 44 (stmt -> return .)
    LOG             reduce using rule 44 (stmt -> return .)
    RCURLY          reduce using rule 44 (stmt -> return .)


state 126

    (38) stmt -> update .

    EXIT            reduce using rule 38 (stmt -> update .)
    IF              reduce using rule 38 (stmt -> update .)
    ATOMIC          reduce using rule 38 (stmt -> update .)
    REMOVE          reduce using rule 38 (stmt -> update .)
    UPDATE          reduce using rule 38 (stmt -> update .)
    MSG             reduce using rule 38 (stmt -> update .)
    LID             reduce using rule 38 (stmt -> update .)
    CID             reduce using rule 38 (stmt -> update .)
    DOREACHAVOID    reduce using rule 38 (stmt -> update .)
    RETURN          reduce using rule 38 (stmt -> update .)
    LOG             reduce using rule 38 (stmt -> update .)
    RCURLY          reduce using rule 38 (stmt -> update .)


state 127

    (31) stmts -> stmt . stmts
    (31) stmts -> . stmt stmts
    (32) stmts -> . empty
    (33) stmt -> . asgn
    (34) stmt -> . exit
    (35) stmt -> . ite
    (36) stmt -> . atomic
    (37) stmt -> . remove
    (38) stmt -> . update
    (39) stmt -> . msg
    (40) stmt -> . funcCall
    (41) stmt -> . getInput
    (42) stmt -> . varname EQLS funcCall
    (43) stmt -> . doreachavoid
    (44) stmt -> . return
    (45) stmt -> . log
    (71) empty -> .
    (63) asgn -> . varname EQLS expr SEMI
    (64) asgn -> . varname INCR SEMI
    (53) exit -> . EXIT SEMI
    (56) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (62) atomic -> . ATOMIC LCURLY stmts RCURLY
    (52) remove -> . REMOVE LPAREN varname COMMA varname RPAREN SEMI
    (46) update -> . UPDATE LPAREN varname RPAREN SEMI
    (48) msg -> . MSG LPAREN varname RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (47) getInput -> . varname EQLS GETINPUT LPAREN RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID
    (55) doreachavoid -> . DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
    (54) return -> . RETURN expr SEMI
    (49) log -> . LOG LPAREN RPAREN SEMI
    (50) log -> . LOG LPAREN DONEFLAG RPAREN SEMI
    (51) log -> . LOG LPAREN FAILFLAG RPAREN SEMI

    RCURLY          reduce using rule 71 (empty -> .)
    EXIT            shift and go to state 135
    IF              shift and go to state 129
    ATOMIC          shift and go to state 136
    REMOVE          shift and go to state 130
    UPDATE          shift and go to state 131
    MSG             shift and go to state 128
    LID             shift and go to state 27
    CID             shift and go to state 28
    DOREACHAVOID    shift and go to state 114
    RETURN          shift and go to state 112
    LOG             shift and go to state 113

    return                         shift and go to state 125
    log                            shift and go to state 119
    funcCall                       shift and go to state 132
    stmts                          shift and go to state 160
    varname                        shift and go to state 133
    update                         shift and go to state 126
    ite                            shift and go to state 115
    remove                         shift and go to state 134
    stmt                           shift and go to state 127
    asgn                           shift and go to state 121
    getInput                       shift and go to state 117
    exit                           shift and go to state 122
    atomic                         shift and go to state 116
    msg                            shift and go to state 123
    doreachavoid                   shift and go to state 118
    empty                          shift and go to state 124

state 128

    (48) msg -> MSG . LPAREN varname RPAREN SEMI

    LPAREN          shift and go to state 161


state 129

    (56) ite -> IF . LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY

    LPAREN          shift and go to state 162


state 130

    (52) remove -> REMOVE . LPAREN varname COMMA varname RPAREN SEMI

    LPAREN          shift and go to state 163


state 131

    (46) update -> UPDATE . LPAREN varname RPAREN SEMI

    LPAREN          shift and go to state 164


state 132

    (40) stmt -> funcCall .

    EXIT            reduce using rule 40 (stmt -> funcCall .)
    IF              reduce using rule 40 (stmt -> funcCall .)
    ATOMIC          reduce using rule 40 (stmt -> funcCall .)
    REMOVE          reduce using rule 40 (stmt -> funcCall .)
    UPDATE          reduce using rule 40 (stmt -> funcCall .)
    MSG             reduce using rule 40 (stmt -> funcCall .)
    LID             reduce using rule 40 (stmt -> funcCall .)
    CID             reduce using rule 40 (stmt -> funcCall .)
    DOREACHAVOID    reduce using rule 40 (stmt -> funcCall .)
    RETURN          reduce using rule 40 (stmt -> funcCall .)
    LOG             reduce using rule 40 (stmt -> funcCall .)
    RCURLY          reduce using rule 40 (stmt -> funcCall .)


state 133

    (42) stmt -> varname . EQLS funcCall
    (63) asgn -> varname . EQLS expr SEMI
    (64) asgn -> varname . INCR SEMI
    (57) funcCall -> varname . LPAREN args RPAREN SEMI
    (47) getInput -> varname . EQLS GETINPUT LPAREN RPAREN SEMI

    EQLS            shift and go to state 166
    INCR            shift and go to state 165
    LPAREN          shift and go to state 167


state 134

    (37) stmt -> remove .

    EXIT            reduce using rule 37 (stmt -> remove .)
    IF              reduce using rule 37 (stmt -> remove .)
    ATOMIC          reduce using rule 37 (stmt -> remove .)
    REMOVE          reduce using rule 37 (stmt -> remove .)
    UPDATE          reduce using rule 37 (stmt -> remove .)
    MSG             reduce using rule 37 (stmt -> remove .)
    LID             reduce using rule 37 (stmt -> remove .)
    CID             reduce using rule 37 (stmt -> remove .)
    DOREACHAVOID    reduce using rule 37 (stmt -> remove .)
    RETURN          reduce using rule 37 (stmt -> remove .)
    LOG             reduce using rule 37 (stmt -> remove .)
    RCURLY          reduce using rule 37 (stmt -> remove .)


state 135

    (53) exit -> EXIT . SEMI

    SEMI            shift and go to state 168


state 136

    (62) atomic -> ATOMIC . LCURLY stmts RCURLY

    LCURLY          shift and go to state 169


state 137

    (18) cond -> cond AND . cond
    (14) cond -> . rel
    (15) cond -> . expr
    (16) cond -> . flag
    (17) cond -> . ISEMPTY LPAREN varname RPAREN
    (18) cond -> . cond AND cond
    (19) cond -> . cond OR cond
    (20) cond -> . NOT expr
    (21) cond -> . LPAREN cond RPAREN
    (24) rel -> . expr EQ expr
    (25) rel -> . expr NEQ expr
    (26) rel -> . expr GEQ expr
    (27) rel -> . expr LEQ expr
    (28) rel -> . expr GE expr
    (29) rel -> . expr LE expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (22) flag -> . DONEFLAG
    (23) flag -> . FAILFLAG
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    ISEMPTY         shift and go to state 102
    NOT             shift and go to state 110
    LPAREN          shift and go to state 104
    DONEFLAG        shift and go to state 108
    FAILFLAG        shift and go to state 103
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    expr                           shift and go to state 106
    flag                           shift and go to state 107
    cond                           shift and go to state 170
    rel                            shift and go to state 101
    varname                        shift and go to state 109

state 138

    (12) pre -> PRE LPAREN cond RPAREN . SEMI

    SEMI            shift and go to state 171


state 139

    (19) cond -> cond OR . cond
    (14) cond -> . rel
    (15) cond -> . expr
    (16) cond -> . flag
    (17) cond -> . ISEMPTY LPAREN varname RPAREN
    (18) cond -> . cond AND cond
    (19) cond -> . cond OR cond
    (20) cond -> . NOT expr
    (21) cond -> . LPAREN cond RPAREN
    (24) rel -> . expr EQ expr
    (25) rel -> . expr NEQ expr
    (26) rel -> . expr GEQ expr
    (27) rel -> . expr LEQ expr
    (28) rel -> . expr GE expr
    (29) rel -> . expr LE expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (22) flag -> . DONEFLAG
    (23) flag -> . FAILFLAG
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    ISEMPTY         shift and go to state 102
    NOT             shift and go to state 110
    LPAREN          shift and go to state 104
    DONEFLAG        shift and go to state 108
    FAILFLAG        shift and go to state 103
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    expr                           shift and go to state 106
    flag                           shift and go to state 107
    cond                           shift and go to state 172
    rel                            shift and go to state 101
    varname                        shift and go to state 109

state 140

    (13) pre -> PRE LPAREN TRUE RPAREN . SEMI

    SEMI            shift and go to state 173


state 141

    (17) cond -> ISEMPTY LPAREN . varname RPAREN
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 174

state 142

    (21) cond -> LPAREN cond . RPAREN
    (18) cond -> cond . AND cond
    (19) cond -> cond . OR cond

    RPAREN          shift and go to state 175
    AND             shift and go to state 137
    OR              shift and go to state 139


state 143

    (91) expr -> LPAREN expr . RPAREN
    (15) cond -> expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr
    (24) rel -> expr . EQ expr
    (25) rel -> expr . NEQ expr
    (26) rel -> expr . GEQ expr
    (27) rel -> expr . LEQ expr
    (28) rel -> expr . GE expr
    (29) rel -> expr . LE expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 176
    AND             reduce using rule 15 (cond -> expr .)
    OR              reduce using rule 15 (cond -> expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146
    EQ              shift and go to state 151
    NEQ             shift and go to state 153
    GEQ             shift and go to state 144
    LEQ             shift and go to state 148
    GE              shift and go to state 149
    LE              shift and go to state 145

  ! RPAREN          [ reduce using rule 15 (cond -> expr .) ]


state 144

    (26) rel -> expr GEQ . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 177
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 145

    (29) rel -> expr LE . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 178
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 146

    (90) expr -> expr BY . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 179
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 147

    (89) expr -> expr TIMES . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 180
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 148

    (27) rel -> expr LEQ . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 181
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 149

    (28) rel -> expr GE . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 182
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 150

    (87) expr -> expr PLUS . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 183
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 151

    (24) rel -> expr EQ . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 184
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 152

    (88) expr -> expr MINUS . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 185
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 153

    (25) rel -> expr NEQ . expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 186
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 154

    (20) cond -> NOT expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 20 (cond -> NOT expr .)
    AND             reduce using rule 20 (cond -> NOT expr .)
    OR              reduce using rule 20 (cond -> NOT expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 155

    (91) expr -> LPAREN . expr RPAREN
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 187
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 156

    (54) return -> RETURN expr . SEMI
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    SEMI            shift and go to state 188
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 157

    (49) log -> LOG LPAREN . RPAREN SEMI
    (50) log -> LOG LPAREN . DONEFLAG RPAREN SEMI
    (51) log -> LOG LPAREN . FAILFLAG RPAREN SEMI

    RPAREN          shift and go to state 190
    DONEFLAG        shift and go to state 191
    FAILFLAG        shift and go to state 189


state 158

    (55) doreachavoid -> DOREACHAVOID LPAREN . varname COMMA expr RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 192

state 159

    (30) eff -> EFF LCURLY stmts RCURLY .

    RCURLY          reduce using rule 30 (eff -> EFF LCURLY stmts RCURLY .)


state 160

    (31) stmts -> stmt stmts .

    RCURLY          reduce using rule 31 (stmts -> stmt stmts .)


state 161

    (48) msg -> MSG LPAREN . varname RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 193

state 162

    (56) ite -> IF LPAREN . cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (14) cond -> . rel
    (15) cond -> . expr
    (16) cond -> . flag
    (17) cond -> . ISEMPTY LPAREN varname RPAREN
    (18) cond -> . cond AND cond
    (19) cond -> . cond OR cond
    (20) cond -> . NOT expr
    (21) cond -> . LPAREN cond RPAREN
    (24) rel -> . expr EQ expr
    (25) rel -> . expr NEQ expr
    (26) rel -> . expr GEQ expr
    (27) rel -> . expr LEQ expr
    (28) rel -> . expr GE expr
    (29) rel -> . expr LE expr
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (22) flag -> . DONEFLAG
    (23) flag -> . FAILFLAG
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    ISEMPTY         shift and go to state 102
    NOT             shift and go to state 110
    LPAREN          shift and go to state 104
    DONEFLAG        shift and go to state 108
    FAILFLAG        shift and go to state 103
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    expr                           shift and go to state 106
    flag                           shift and go to state 107
    cond                           shift and go to state 194
    rel                            shift and go to state 101
    varname                        shift and go to state 109

state 163

    (52) remove -> REMOVE LPAREN . varname COMMA varname RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 195

state 164

    (46) update -> UPDATE LPAREN . varname RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 196

state 165

    (64) asgn -> varname INCR . SEMI

    SEMI            shift and go to state 197


state 166

    (42) stmt -> varname EQLS . funcCall
    (63) asgn -> varname EQLS . expr SEMI
    (47) getInput -> varname EQLS . GETINPUT LPAREN RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (97) varname -> . LID
    (98) varname -> . CID
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL

    GETINPUT        shift and go to state 201
    LPAREN          shift and go to state 155
    LID             shift and go to state 27
    CID             shift and go to state 28
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48

    varname                        shift and go to state 199
    val                            shift and go to state 105
    funcCall                       shift and go to state 198
    expr                           shift and go to state 200

state 167

    (57) funcCall -> varname LPAREN . args RPAREN SEMI
    (58) args -> . empty
    (59) args -> . neargs
    (71) empty -> .
    (60) neargs -> . expr
    (61) neargs -> . expr COMMA neargs
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    RPAREN          reduce using rule 71 (empty -> .)
    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    val                            shift and go to state 105
    varname                        shift and go to state 109
    args                           shift and go to state 202
    expr                           shift and go to state 203
    neargs                         shift and go to state 204
    empty                          shift and go to state 205

state 168

    (53) exit -> EXIT SEMI .

    EXIT            reduce using rule 53 (exit -> EXIT SEMI .)
    IF              reduce using rule 53 (exit -> EXIT SEMI .)
    ATOMIC          reduce using rule 53 (exit -> EXIT SEMI .)
    REMOVE          reduce using rule 53 (exit -> EXIT SEMI .)
    UPDATE          reduce using rule 53 (exit -> EXIT SEMI .)
    MSG             reduce using rule 53 (exit -> EXIT SEMI .)
    LID             reduce using rule 53 (exit -> EXIT SEMI .)
    CID             reduce using rule 53 (exit -> EXIT SEMI .)
    DOREACHAVOID    reduce using rule 53 (exit -> EXIT SEMI .)
    RETURN          reduce using rule 53 (exit -> EXIT SEMI .)
    LOG             reduce using rule 53 (exit -> EXIT SEMI .)
    RCURLY          reduce using rule 53 (exit -> EXIT SEMI .)


state 169

    (62) atomic -> ATOMIC LCURLY . stmts RCURLY
    (31) stmts -> . stmt stmts
    (32) stmts -> . empty
    (33) stmt -> . asgn
    (34) stmt -> . exit
    (35) stmt -> . ite
    (36) stmt -> . atomic
    (37) stmt -> . remove
    (38) stmt -> . update
    (39) stmt -> . msg
    (40) stmt -> . funcCall
    (41) stmt -> . getInput
    (42) stmt -> . varname EQLS funcCall
    (43) stmt -> . doreachavoid
    (44) stmt -> . return
    (45) stmt -> . log
    (71) empty -> .
    (63) asgn -> . varname EQLS expr SEMI
    (64) asgn -> . varname INCR SEMI
    (53) exit -> . EXIT SEMI
    (56) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (62) atomic -> . ATOMIC LCURLY stmts RCURLY
    (52) remove -> . REMOVE LPAREN varname COMMA varname RPAREN SEMI
    (46) update -> . UPDATE LPAREN varname RPAREN SEMI
    (48) msg -> . MSG LPAREN varname RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (47) getInput -> . varname EQLS GETINPUT LPAREN RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID
    (55) doreachavoid -> . DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
    (54) return -> . RETURN expr SEMI
    (49) log -> . LOG LPAREN RPAREN SEMI
    (50) log -> . LOG LPAREN DONEFLAG RPAREN SEMI
    (51) log -> . LOG LPAREN FAILFLAG RPAREN SEMI

    RCURLY          reduce using rule 71 (empty -> .)
    EXIT            shift and go to state 135
    IF              shift and go to state 129
    ATOMIC          shift and go to state 136
    REMOVE          shift and go to state 130
    UPDATE          shift and go to state 131
    MSG             shift and go to state 128
    LID             shift and go to state 27
    CID             shift and go to state 28
    DOREACHAVOID    shift and go to state 114
    RETURN          shift and go to state 112
    LOG             shift and go to state 113

    return                         shift and go to state 125
    log                            shift and go to state 119
    funcCall                       shift and go to state 132
    stmts                          shift and go to state 206
    varname                        shift and go to state 133
    update                         shift and go to state 126
    ite                            shift and go to state 115
    remove                         shift and go to state 134
    stmt                           shift and go to state 127
    asgn                           shift and go to state 121
    getInput                       shift and go to state 117
    exit                           shift and go to state 122
    atomic                         shift and go to state 116
    msg                            shift and go to state 123
    doreachavoid                   shift and go to state 118
    empty                          shift and go to state 124

state 170

    (18) cond -> cond AND cond .
    (18) cond -> cond . AND cond
    (19) cond -> cond . OR cond

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 18 (cond -> cond AND cond .)
    AND             shift and go to state 137
    OR              shift and go to state 139

  ! AND             [ reduce using rule 18 (cond -> cond AND cond .) ]
  ! OR              [ reduce using rule 18 (cond -> cond AND cond .) ]


state 171

    (12) pre -> PRE LPAREN cond RPAREN SEMI .

    EFF             reduce using rule 12 (pre -> PRE LPAREN cond RPAREN SEMI .)


state 172

    (19) cond -> cond OR cond .
    (18) cond -> cond . AND cond
    (19) cond -> cond . OR cond

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 19 (cond -> cond OR cond .)
    AND             shift and go to state 137
    OR              shift and go to state 139

  ! AND             [ reduce using rule 19 (cond -> cond OR cond .) ]
  ! OR              [ reduce using rule 19 (cond -> cond OR cond .) ]


state 173

    (13) pre -> PRE LPAREN TRUE RPAREN SEMI .

    EFF             reduce using rule 13 (pre -> PRE LPAREN TRUE RPAREN SEMI .)


state 174

    (17) cond -> ISEMPTY LPAREN varname . RPAREN

    RPAREN          shift and go to state 207


state 175

    (21) cond -> LPAREN cond RPAREN .

    RPAREN          reduce using rule 21 (cond -> LPAREN cond RPAREN .)
    AND             reduce using rule 21 (cond -> LPAREN cond RPAREN .)
    OR              reduce using rule 21 (cond -> LPAREN cond RPAREN .)


state 176

    (91) expr -> LPAREN expr RPAREN .

    RPAREN          reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    BY              reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 91 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 91 (expr -> LPAREN expr RPAREN .)


state 177

    (26) rel -> expr GEQ expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 26 (rel -> expr GEQ expr .)
    OR              reduce using rule 26 (rel -> expr GEQ expr .)
    RPAREN          reduce using rule 26 (rel -> expr GEQ expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 178

    (29) rel -> expr LE expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 29 (rel -> expr LE expr .)
    OR              reduce using rule 29 (rel -> expr LE expr .)
    RPAREN          reduce using rule 29 (rel -> expr LE expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 179

    (90) expr -> expr BY expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 90 (expr -> expr BY expr .)
    PLUS            reduce using rule 90 (expr -> expr BY expr .)
    MINUS           reduce using rule 90 (expr -> expr BY expr .)
    TIMES           reduce using rule 90 (expr -> expr BY expr .)
    BY              reduce using rule 90 (expr -> expr BY expr .)
    EQ              reduce using rule 90 (expr -> expr BY expr .)
    NEQ             reduce using rule 90 (expr -> expr BY expr .)
    GEQ             reduce using rule 90 (expr -> expr BY expr .)
    LEQ             reduce using rule 90 (expr -> expr BY expr .)
    GE              reduce using rule 90 (expr -> expr BY expr .)
    LE              reduce using rule 90 (expr -> expr BY expr .)
    AND             reduce using rule 90 (expr -> expr BY expr .)
    OR              reduce using rule 90 (expr -> expr BY expr .)
    SEMI            reduce using rule 90 (expr -> expr BY expr .)
    COMMA           reduce using rule 90 (expr -> expr BY expr .)

  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 152 ]
  ! TIMES           [ shift and go to state 147 ]
  ! BY              [ shift and go to state 146 ]


state 180

    (89) expr -> expr TIMES expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 89 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 89 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 89 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 89 (expr -> expr TIMES expr .)
    BY              reduce using rule 89 (expr -> expr TIMES expr .)
    EQ              reduce using rule 89 (expr -> expr TIMES expr .)
    NEQ             reduce using rule 89 (expr -> expr TIMES expr .)
    GEQ             reduce using rule 89 (expr -> expr TIMES expr .)
    LEQ             reduce using rule 89 (expr -> expr TIMES expr .)
    GE              reduce using rule 89 (expr -> expr TIMES expr .)
    LE              reduce using rule 89 (expr -> expr TIMES expr .)
    AND             reduce using rule 89 (expr -> expr TIMES expr .)
    OR              reduce using rule 89 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 89 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 89 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 152 ]
  ! TIMES           [ shift and go to state 147 ]
  ! BY              [ shift and go to state 146 ]


state 181

    (27) rel -> expr LEQ expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 27 (rel -> expr LEQ expr .)
    OR              reduce using rule 27 (rel -> expr LEQ expr .)
    RPAREN          reduce using rule 27 (rel -> expr LEQ expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 182

    (28) rel -> expr GE expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 28 (rel -> expr GE expr .)
    OR              reduce using rule 28 (rel -> expr GE expr .)
    RPAREN          reduce using rule 28 (rel -> expr GE expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 183

    (87) expr -> expr PLUS expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 87 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 87 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 87 (expr -> expr PLUS expr .)
    EQ              reduce using rule 87 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 87 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 87 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 87 (expr -> expr PLUS expr .)
    GE              reduce using rule 87 (expr -> expr PLUS expr .)
    LE              reduce using rule 87 (expr -> expr PLUS expr .)
    AND             reduce using rule 87 (expr -> expr PLUS expr .)
    OR              reduce using rule 87 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 87 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 87 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 147
    BY              shift and go to state 146

  ! TIMES           [ reduce using rule 87 (expr -> expr PLUS expr .) ]
  ! BY              [ reduce using rule 87 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 152 ]


state 184

    (24) rel -> expr EQ expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 24 (rel -> expr EQ expr .)
    OR              reduce using rule 24 (rel -> expr EQ expr .)
    RPAREN          reduce using rule 24 (rel -> expr EQ expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 185

    (88) expr -> expr MINUS expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 88 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 88 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 88 (expr -> expr MINUS expr .)
    EQ              reduce using rule 88 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 88 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 88 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 88 (expr -> expr MINUS expr .)
    GE              reduce using rule 88 (expr -> expr MINUS expr .)
    LE              reduce using rule 88 (expr -> expr MINUS expr .)
    AND             reduce using rule 88 (expr -> expr MINUS expr .)
    OR              reduce using rule 88 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 88 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 88 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 147
    BY              shift and go to state 146

  ! TIMES           [ reduce using rule 88 (expr -> expr MINUS expr .) ]
  ! BY              [ reduce using rule 88 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 152 ]


state 186

    (25) rel -> expr NEQ expr .
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    AND             reduce using rule 25 (rel -> expr NEQ expr .)
    OR              reduce using rule 25 (rel -> expr NEQ expr .)
    RPAREN          reduce using rule 25 (rel -> expr NEQ expr .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 187

    (91) expr -> LPAREN expr . RPAREN
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          shift and go to state 176
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 188

    (54) return -> RETURN expr SEMI .

    EXIT            reduce using rule 54 (return -> RETURN expr SEMI .)
    IF              reduce using rule 54 (return -> RETURN expr SEMI .)
    ATOMIC          reduce using rule 54 (return -> RETURN expr SEMI .)
    REMOVE          reduce using rule 54 (return -> RETURN expr SEMI .)
    UPDATE          reduce using rule 54 (return -> RETURN expr SEMI .)
    MSG             reduce using rule 54 (return -> RETURN expr SEMI .)
    LID             reduce using rule 54 (return -> RETURN expr SEMI .)
    CID             reduce using rule 54 (return -> RETURN expr SEMI .)
    DOREACHAVOID    reduce using rule 54 (return -> RETURN expr SEMI .)
    RETURN          reduce using rule 54 (return -> RETURN expr SEMI .)
    LOG             reduce using rule 54 (return -> RETURN expr SEMI .)
    RCURLY          reduce using rule 54 (return -> RETURN expr SEMI .)


state 189

    (51) log -> LOG LPAREN FAILFLAG . RPAREN SEMI

    RPAREN          shift and go to state 208


state 190

    (49) log -> LOG LPAREN RPAREN . SEMI

    SEMI            shift and go to state 209


state 191

    (50) log -> LOG LPAREN DONEFLAG . RPAREN SEMI

    RPAREN          shift and go to state 210


state 192

    (55) doreachavoid -> DOREACHAVOID LPAREN varname . COMMA expr RPAREN SEMI

    COMMA           shift and go to state 211


state 193

    (48) msg -> MSG LPAREN varname . RPAREN SEMI

    RPAREN          shift and go to state 212


state 194

    (56) ite -> IF LPAREN cond . RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (18) cond -> cond . AND cond
    (19) cond -> cond . OR cond

    RPAREN          shift and go to state 213
    AND             shift and go to state 137
    OR              shift and go to state 139


state 195

    (52) remove -> REMOVE LPAREN varname . COMMA varname RPAREN SEMI

    COMMA           shift and go to state 214


state 196

    (46) update -> UPDATE LPAREN varname . RPAREN SEMI

    RPAREN          shift and go to state 215


state 197

    (64) asgn -> varname INCR SEMI .

    EXIT            reduce using rule 64 (asgn -> varname INCR SEMI .)
    IF              reduce using rule 64 (asgn -> varname INCR SEMI .)
    ATOMIC          reduce using rule 64 (asgn -> varname INCR SEMI .)
    REMOVE          reduce using rule 64 (asgn -> varname INCR SEMI .)
    UPDATE          reduce using rule 64 (asgn -> varname INCR SEMI .)
    MSG             reduce using rule 64 (asgn -> varname INCR SEMI .)
    LID             reduce using rule 64 (asgn -> varname INCR SEMI .)
    CID             reduce using rule 64 (asgn -> varname INCR SEMI .)
    DOREACHAVOID    reduce using rule 64 (asgn -> varname INCR SEMI .)
    RETURN          reduce using rule 64 (asgn -> varname INCR SEMI .)
    LOG             reduce using rule 64 (asgn -> varname INCR SEMI .)
    RCURLY          reduce using rule 64 (asgn -> varname INCR SEMI .)


state 198

    (42) stmt -> varname EQLS funcCall .

    EXIT            reduce using rule 42 (stmt -> varname EQLS funcCall .)
    IF              reduce using rule 42 (stmt -> varname EQLS funcCall .)
    ATOMIC          reduce using rule 42 (stmt -> varname EQLS funcCall .)
    REMOVE          reduce using rule 42 (stmt -> varname EQLS funcCall .)
    UPDATE          reduce using rule 42 (stmt -> varname EQLS funcCall .)
    MSG             reduce using rule 42 (stmt -> varname EQLS funcCall .)
    LID             reduce using rule 42 (stmt -> varname EQLS funcCall .)
    CID             reduce using rule 42 (stmt -> varname EQLS funcCall .)
    DOREACHAVOID    reduce using rule 42 (stmt -> varname EQLS funcCall .)
    RETURN          reduce using rule 42 (stmt -> varname EQLS funcCall .)
    LOG             reduce using rule 42 (stmt -> varname EQLS funcCall .)
    RCURLY          reduce using rule 42 (stmt -> varname EQLS funcCall .)


state 199

    (57) funcCall -> varname . LPAREN args RPAREN SEMI
    (86) expr -> varname .

    LPAREN          shift and go to state 167
    SEMI            reduce using rule 86 (expr -> varname .)
    PLUS            reduce using rule 86 (expr -> varname .)
    MINUS           reduce using rule 86 (expr -> varname .)
    TIMES           reduce using rule 86 (expr -> varname .)
    BY              reduce using rule 86 (expr -> varname .)


state 200

    (63) asgn -> varname EQLS expr . SEMI
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    SEMI            shift and go to state 216
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 201

    (47) getInput -> varname EQLS GETINPUT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 217


state 202

    (57) funcCall -> varname LPAREN args . RPAREN SEMI

    RPAREN          shift and go to state 218


state 203

    (60) neargs -> expr .
    (61) neargs -> expr . COMMA neargs
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          reduce using rule 60 (neargs -> expr .)
    COMMA           shift and go to state 219
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 204

    (59) args -> neargs .

    RPAREN          reduce using rule 59 (args -> neargs .)


state 205

    (58) args -> empty .

    RPAREN          reduce using rule 58 (args -> empty .)


state 206

    (62) atomic -> ATOMIC LCURLY stmts . RCURLY

    RCURLY          shift and go to state 220


state 207

    (17) cond -> ISEMPTY LPAREN varname RPAREN .

    RPAREN          reduce using rule 17 (cond -> ISEMPTY LPAREN varname RPAREN .)
    AND             reduce using rule 17 (cond -> ISEMPTY LPAREN varname RPAREN .)
    OR              reduce using rule 17 (cond -> ISEMPTY LPAREN varname RPAREN .)


state 208

    (51) log -> LOG LPAREN FAILFLAG RPAREN . SEMI

    SEMI            shift and go to state 221


state 209

    (49) log -> LOG LPAREN RPAREN SEMI .

    EXIT            reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    IF              reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    ATOMIC          reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    REMOVE          reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    UPDATE          reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    MSG             reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    LID             reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    CID             reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    LOG             reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)
    RCURLY          reduce using rule 49 (log -> LOG LPAREN RPAREN SEMI .)


state 210

    (50) log -> LOG LPAREN DONEFLAG RPAREN . SEMI

    SEMI            shift and go to state 222


state 211

    (55) doreachavoid -> DOREACHAVOID LPAREN varname COMMA . expr RPAREN SEMI
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 109
    val                            shift and go to state 105
    expr                           shift and go to state 223

state 212

    (48) msg -> MSG LPAREN varname RPAREN . SEMI

    SEMI            shift and go to state 224


state 213

    (56) ite -> IF LPAREN cond RPAREN . LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY

    LCURLY          shift and go to state 225


state 214

    (52) remove -> REMOVE LPAREN varname COMMA . varname RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID

    LID             shift and go to state 27
    CID             shift and go to state 28

    varname                        shift and go to state 226

state 215

    (46) update -> UPDATE LPAREN varname RPAREN . SEMI

    SEMI            shift and go to state 227


state 216

    (63) asgn -> varname EQLS expr SEMI .

    EXIT            reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    IF              reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    ATOMIC          reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    REMOVE          reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    UPDATE          reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    MSG             reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    LID             reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    CID             reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    DOREACHAVOID    reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    RETURN          reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    LOG             reduce using rule 63 (asgn -> varname EQLS expr SEMI .)
    RCURLY          reduce using rule 63 (asgn -> varname EQLS expr SEMI .)


state 217

    (47) getInput -> varname EQLS GETINPUT LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 228


state 218

    (57) funcCall -> varname LPAREN args RPAREN . SEMI

    SEMI            shift and go to state 229


state 219

    (61) neargs -> expr COMMA . neargs
    (60) neargs -> . expr
    (61) neargs -> . expr COMMA neargs
    (85) expr -> . val
    (86) expr -> . varname
    (87) expr -> . expr PLUS expr
    (88) expr -> . expr MINUS expr
    (89) expr -> . expr TIMES expr
    (90) expr -> . expr BY expr
    (91) expr -> . LPAREN expr RPAREN
    (80) val -> . INUM
    (81) val -> . FNUM
    (82) val -> . TRUE
    (83) val -> . FALSE
    (84) val -> . NULL
    (97) varname -> . LID
    (98) varname -> . CID

    LPAREN          shift and go to state 155
    INUM            shift and go to state 47
    FNUM            shift and go to state 46
    TRUE            shift and go to state 49
    FALSE           shift and go to state 44
    NULL            shift and go to state 48
    LID             shift and go to state 27
    CID             shift and go to state 28

    expr                           shift and go to state 203
    neargs                         shift and go to state 230
    val                            shift and go to state 105
    varname                        shift and go to state 109

state 220

    (62) atomic -> ATOMIC LCURLY stmts RCURLY .

    EXIT            reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    IF              reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    ATOMIC          reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    REMOVE          reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    UPDATE          reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    MSG             reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    LID             reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    CID             reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    DOREACHAVOID    reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    RETURN          reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    LOG             reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    RCURLY          reduce using rule 62 (atomic -> ATOMIC LCURLY stmts RCURLY .)


state 221

    (51) log -> LOG LPAREN FAILFLAG RPAREN SEMI .

    EXIT            reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    IF              reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    ATOMIC          reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    REMOVE          reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    UPDATE          reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    MSG             reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    LID             reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    CID             reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    RETURN          reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    LOG             reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)
    RCURLY          reduce using rule 51 (log -> LOG LPAREN FAILFLAG RPAREN SEMI .)


state 222

    (50) log -> LOG LPAREN DONEFLAG RPAREN SEMI .

    EXIT            reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    IF              reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    ATOMIC          reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    REMOVE          reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    UPDATE          reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    MSG             reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    LID             reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    CID             reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    RETURN          reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    LOG             reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)
    RCURLY          reduce using rule 50 (log -> LOG LPAREN DONEFLAG RPAREN SEMI .)


state 223

    (55) doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr . RPAREN SEMI
    (87) expr -> expr . PLUS expr
    (88) expr -> expr . MINUS expr
    (89) expr -> expr . TIMES expr
    (90) expr -> expr . BY expr

    RPAREN          shift and go to state 231
    PLUS            shift and go to state 150
    MINUS           shift and go to state 152
    TIMES           shift and go to state 147
    BY              shift and go to state 146


state 224

    (48) msg -> MSG LPAREN varname RPAREN SEMI .

    EXIT            reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    IF              reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    ATOMIC          reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    REMOVE          reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    UPDATE          reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    MSG             reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    LID             reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    CID             reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    RETURN          reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    LOG             reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)
    RCURLY          reduce using rule 48 (msg -> MSG LPAREN varname RPAREN SEMI .)


state 225

    (56) ite -> IF LPAREN cond RPAREN LCURLY . stmts RCURLY ELSE LCURLY stmts RCURLY
    (31) stmts -> . stmt stmts
    (32) stmts -> . empty
    (33) stmt -> . asgn
    (34) stmt -> . exit
    (35) stmt -> . ite
    (36) stmt -> . atomic
    (37) stmt -> . remove
    (38) stmt -> . update
    (39) stmt -> . msg
    (40) stmt -> . funcCall
    (41) stmt -> . getInput
    (42) stmt -> . varname EQLS funcCall
    (43) stmt -> . doreachavoid
    (44) stmt -> . return
    (45) stmt -> . log
    (71) empty -> .
    (63) asgn -> . varname EQLS expr SEMI
    (64) asgn -> . varname INCR SEMI
    (53) exit -> . EXIT SEMI
    (56) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (62) atomic -> . ATOMIC LCURLY stmts RCURLY
    (52) remove -> . REMOVE LPAREN varname COMMA varname RPAREN SEMI
    (46) update -> . UPDATE LPAREN varname RPAREN SEMI
    (48) msg -> . MSG LPAREN varname RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (47) getInput -> . varname EQLS GETINPUT LPAREN RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID
    (55) doreachavoid -> . DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
    (54) return -> . RETURN expr SEMI
    (49) log -> . LOG LPAREN RPAREN SEMI
    (50) log -> . LOG LPAREN DONEFLAG RPAREN SEMI
    (51) log -> . LOG LPAREN FAILFLAG RPAREN SEMI

    RCURLY          reduce using rule 71 (empty -> .)
    EXIT            shift and go to state 135
    IF              shift and go to state 129
    ATOMIC          shift and go to state 136
    REMOVE          shift and go to state 130
    UPDATE          shift and go to state 131
    MSG             shift and go to state 128
    LID             shift and go to state 27
    CID             shift and go to state 28
    DOREACHAVOID    shift and go to state 114
    RETURN          shift and go to state 112
    LOG             shift and go to state 113

    return                         shift and go to state 125
    log                            shift and go to state 119
    funcCall                       shift and go to state 132
    stmts                          shift and go to state 232
    varname                        shift and go to state 133
    update                         shift and go to state 126
    ite                            shift and go to state 115
    remove                         shift and go to state 134
    stmt                           shift and go to state 127
    asgn                           shift and go to state 121
    getInput                       shift and go to state 117
    exit                           shift and go to state 122
    atomic                         shift and go to state 116
    msg                            shift and go to state 123
    doreachavoid                   shift and go to state 118
    empty                          shift and go to state 124

state 226

    (52) remove -> REMOVE LPAREN varname COMMA varname . RPAREN SEMI

    RPAREN          shift and go to state 233


state 227

    (46) update -> UPDATE LPAREN varname RPAREN SEMI .

    EXIT            reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    IF              reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    ATOMIC          reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    REMOVE          reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    UPDATE          reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    MSG             reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    LID             reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    CID             reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    RETURN          reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    LOG             reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)
    RCURLY          reduce using rule 46 (update -> UPDATE LPAREN varname RPAREN SEMI .)


state 228

    (47) getInput -> varname EQLS GETINPUT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 234


state 229

    (57) funcCall -> varname LPAREN args RPAREN SEMI .

    EXIT            reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    IF              reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    ATOMIC          reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    REMOVE          reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    UPDATE          reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    MSG             reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    LID             reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    CID             reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    RETURN          reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    LOG             reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)
    RCURLY          reduce using rule 57 (funcCall -> varname LPAREN args RPAREN SEMI .)


state 230

    (61) neargs -> expr COMMA neargs .

    RPAREN          reduce using rule 61 (neargs -> expr COMMA neargs .)


state 231

    (55) doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN . SEMI

    SEMI            shift and go to state 235


state 232

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts . RCURLY ELSE LCURLY stmts RCURLY

    RCURLY          shift and go to state 236


state 233

    (52) remove -> REMOVE LPAREN varname COMMA varname RPAREN . SEMI

    SEMI            shift and go to state 237


state 234

    (47) getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .

    EXIT            reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    IF              reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    ATOMIC          reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    REMOVE          reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    UPDATE          reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    MSG             reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    LID             reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    CID             reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    RETURN          reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    LOG             reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)
    RCURLY          reduce using rule 47 (getInput -> varname EQLS GETINPUT LPAREN RPAREN SEMI .)


state 235

    (55) doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .

    EXIT            reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    IF              reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    ATOMIC          reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    REMOVE          reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    UPDATE          reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    MSG             reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    LID             reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    CID             reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    RETURN          reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    LOG             reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)
    RCURLY          reduce using rule 55 (doreachavoid -> DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI .)


state 236

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY . ELSE LCURLY stmts RCURLY

    ELSE            shift and go to state 238


state 237

    (52) remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .

    EXIT            reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    IF              reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    ATOMIC          reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    REMOVE          reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    UPDATE          reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    MSG             reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    LID             reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    CID             reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    DOREACHAVOID    reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    RETURN          reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    LOG             reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)
    RCURLY          reduce using rule 52 (remove -> REMOVE LPAREN varname COMMA varname RPAREN SEMI .)


state 238

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE . LCURLY stmts RCURLY

    LCURLY          shift and go to state 239


state 239

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY . stmts RCURLY
    (31) stmts -> . stmt stmts
    (32) stmts -> . empty
    (33) stmt -> . asgn
    (34) stmt -> . exit
    (35) stmt -> . ite
    (36) stmt -> . atomic
    (37) stmt -> . remove
    (38) stmt -> . update
    (39) stmt -> . msg
    (40) stmt -> . funcCall
    (41) stmt -> . getInput
    (42) stmt -> . varname EQLS funcCall
    (43) stmt -> . doreachavoid
    (44) stmt -> . return
    (45) stmt -> . log
    (71) empty -> .
    (63) asgn -> . varname EQLS expr SEMI
    (64) asgn -> . varname INCR SEMI
    (53) exit -> . EXIT SEMI
    (56) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (62) atomic -> . ATOMIC LCURLY stmts RCURLY
    (52) remove -> . REMOVE LPAREN varname COMMA varname RPAREN SEMI
    (46) update -> . UPDATE LPAREN varname RPAREN SEMI
    (48) msg -> . MSG LPAREN varname RPAREN SEMI
    (57) funcCall -> . varname LPAREN args RPAREN SEMI
    (47) getInput -> . varname EQLS GETINPUT LPAREN RPAREN SEMI
    (97) varname -> . LID
    (98) varname -> . CID
    (55) doreachavoid -> . DOREACHAVOID LPAREN varname COMMA expr RPAREN SEMI
    (54) return -> . RETURN expr SEMI
    (49) log -> . LOG LPAREN RPAREN SEMI
    (50) log -> . LOG LPAREN DONEFLAG RPAREN SEMI
    (51) log -> . LOG LPAREN FAILFLAG RPAREN SEMI

    RCURLY          reduce using rule 71 (empty -> .)
    EXIT            shift and go to state 135
    IF              shift and go to state 129
    ATOMIC          shift and go to state 136
    REMOVE          shift and go to state 130
    UPDATE          shift and go to state 131
    MSG             shift and go to state 128
    LID             shift and go to state 27
    CID             shift and go to state 28
    DOREACHAVOID    shift and go to state 114
    RETURN          shift and go to state 112
    LOG             shift and go to state 113

    return                         shift and go to state 125
    log                            shift and go to state 119
    funcCall                       shift and go to state 132
    stmts                          shift and go to state 240
    varname                        shift and go to state 133
    update                         shift and go to state 126
    ite                            shift and go to state 115
    remove                         shift and go to state 134
    stmt                           shift and go to state 127
    asgn                           shift and go to state 121
    getInput                       shift and go to state 117
    exit                           shift and go to state 122
    atomic                         shift and go to state 116
    msg                            shift and go to state 123
    doreachavoid                   shift and go to state 118
    empty                          shift and go to state 124

state 240

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts . RCURLY

    RCURLY          shift and go to state 241


state 241

    (56) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .

    EXIT            reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    IF              reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    ATOMIC          reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    REMOVE          reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    UPDATE          reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    MSG             reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    LID             reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    CID             reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    DOREACHAVOID    reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    RETURN          reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    LOG             reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    RCURLY          reduce using rule 56 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 170 resolved as shift
WARNING: shift/reduce conflict for OR in state 170 resolved as shift
WARNING: shift/reduce conflict for AND in state 172 resolved as shift
WARNING: shift/reduce conflict for OR in state 172 resolved as shift
